#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Plane
{
    vec3    N; // Plane normal
    float   d; // Distance to origin
};

struct Frustum
{
    vec4    N[4];
    float   d[4];
};

layout (std430, binding = 0) writeonly buffer FrustumBuffer
{
    Frustum gFrustumBuffer[];
};

uniform mat4 invProjection;

uniform int tileSize;
uniform int screenWidth;
uniform int screenHeight;

// Convert clip space coordinates to view space
vec4 clipToView(vec4 clip)
{
    vec4 view = invProjection * clip;
    view = view / view.w;
    return view;
}

// Convert screen space coordinates to view space
vec4 screenToView(vec4 screen)
{
    // Convert to normalized texture coordinates
    vec2 texCoord = screen.xy / vec2(screenWidth, screenHeight);
    // Convert to clip space
    vec4 clip = vec4(texCoord.xy * 2.0f - 1.0f, screen.z, screen.w);

    return clipToView(clip);
}

Plane computePlane(vec3 p0, vec3 p1, vec3 p2)
{
    Plane plane;
    vec3 v0 = p1 - p0;
    vec3 v2 = p2 - p0;
    plane.N = normalize(cross(v0, v2));
    plane.d = dot(plane.N, p0);
    return plane;
}

void main()
{
    vec4 screenSpace[4]; // Four corners of the tile in the screen space
    screenSpace[0] = vec4(     gl_GlobalInvocationID.xy                                  * tileSize, -1.0f, 1.0f);
    screenSpace[1] = vec4(vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y)     * tileSize, -1.0f, 1.0f);
    screenSpace[2] = vec4(vec2(gl_GlobalInvocationID.x,     gl_GlobalInvocationID.y + 1) * tileSize, -1.0f, 1.0f);
    screenSpace[3] = vec4(vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y + 1) * tileSize, -1.0f, 1.0f);

    vec3 viewSpace[4]; // Get the corners in the view space
    for (int i = 0; i < 4; ++i)
    {
        viewSpace[i] = screenToView(screenSpace[i]).xyz;
    }

    const vec3 eyePos = vec3(0,0,0);

    // Tile planes
    Plane p0 = computePlane(eyePos, viewSpace[0], viewSpace[2]); // Left
    Plane p1 = computePlane(eyePos, viewSpace[3], viewSpace[1]); // Right
    Plane p2 = computePlane(eyePos, viewSpace[2], viewSpace[3]); // Top
    Plane p3 = computePlane(eyePos, viewSpace[1], viewSpace[0]); // Bottom

    Frustum frustum;
    frustum.N[0] = vec4(p0.N, 0);
    frustum.d[0] = p0.d;
    frustum.N[1] = vec4(p1.N, 0);
    frustum.d[1] = p1.d;
    frustum.N[2] = vec4(p2.N, 0);
    frustum.d[2] = p2.d;
    frustum.N[3] = vec4(p3.N, 0);
    frustum.d[3] = p3.d;

    if (gl_GlobalInvocationID.x < gl_NumWorkGroups.x * gl_WorkGroupSize.x && gl_GlobalInvocationID.y < gl_NumWorkGroups.y * gl_WorkGroupSize.y)
    {
        uint index = gl_GlobalInvocationID.x + ( gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x));
        gFrustumBuffer[index] = frustum;
    }
}
