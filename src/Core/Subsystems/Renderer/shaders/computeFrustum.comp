#version 460 core

layout (local_size_x = 16, local_size_y = 16) in;

struct PointLight
{
    vec3    color;
    float   radius;
    vec3    position;
};

struct Sphere
{
    vec3    c; // Center point
    float   r; // Radius 
};

struct Plane
{
    vec3    N; // Normal
    float   d; // Distance to origin
};

struct Frustum
{
    Plane planes[4]; // Left, Right, Top, Bottom
};

layout (std430, binding = 0) writeonly buffer FrustumBuffer
{
    Frustum gFrustumBuffer[];
};

uniform mat4 invProjection;
uniform mat4 view;

uniform int blockSize;
uniform int screenWidth;
uniform int screenHeight;

// Convert clip space coordinates to view space
vec4 clipToView(vec4 clip)
{
    vec4 view = clip * invProjection;
    view = view / view.w;
    return view;
}

// Convert screen space coordinates to view space
vec4 screenToView(vec4 screen)
{
    // Convert to normalized texture coordinates
    vec2 texCoord = screen.xy / vec2(screenWidth, screenHeight);
    // Convert to clip space
    vec4 clip = vec4(vec2(texCoord.x, 1.0f - texCoord.y) * 2.0f - 1.0f, screen.z, screen.w);
    return screen;
}

Plane computePlane(vec3 p0, vec3 p1, vec3 p2)
{
    Plane plane;
    vec3 v0 = p1 - p0;
    vec3 v2 = p2 - p0;
    plane.N = normalize(cross(v0, v2));
    plane.d = dot(plane.N, p0);
    return plane;
}

bool sphereInsidePlane(Sphere sphere, Plane plane)
{
    return dot(plane.N, sphere.c) - plane.d < -sphere.r;
}

bool sphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)
{
    bool result = true;

    // Check if in range of depth
    if (sphere.c.z - sphere.r > zFar || sphere.c.z + sphere.r < zNear)
    {
        result = false;
    }
    
    // Check if in frustum with its 4 planes
    for (int i = 0; i < 4 && result; ++i)
    {
        if (sphereInsidePlane(sphere, frustum.planes[i]))
        {
            result = false;
        }
    }

    return result;
}

void main()
{
    const vec3 eyePos = vec3(0,0,0); // Screenspace

    vec4 screenSpace[4];
    screenSpace[0] = vec4(gl_WorkGroupID.xy * blockSize, 1.0f, 1.0f);
    screenSpace[1] = vec4(vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y) * blockSize, 1.0f, 1.0f);
    screenSpace[2] = vec4(vec2(gl_WorkGroupID.x, gl_WorkGroupID.y + 1) * blockSize, 1.0f, 1.0f);
    screenSpace[3] = vec4(vec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1) * blockSize, 1.0f, 1.0f);

    vec3 viewSpace[4];
    for (int i = 0; i < 4; ++i)
    {
        viewSpace[i] = screenToView(screenSpace[i]).xyz;
    }

    Frustum frustum;
    frustum.planes[0] = computePlane(eyePos, viewSpace[2], viewSpace[0]);
    frustum.planes[1] = computePlane(eyePos, viewSpace[1], viewSpace[3]);
    frustum.planes[2] = computePlane(eyePos, viewSpace[0], viewSpace[1]);
    frustum.planes[3] = computePlane(eyePos, viewSpace[3], viewSpace[2]);

    if (gl_WorkGroupID.x < gl_GlobalInvocationID.x && gl_WorkGroupID.y < gl_GlobalInvocationID.y)
    {
        gFrustumBuffer[gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_GlobalInvocationID.x)] = frustum;
    }
}
