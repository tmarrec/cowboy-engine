#version 460 core

#define PI 3.14159265359
#define MAX_LIGHTS_PER_TILE 256

layout (local_size_x = 16, local_size_y = 16) in;

struct PointLight
{
    vec3    color;
    float   radius;
    vec4    position;
    vec4    positionVS;
};

struct Plane
{
    vec3    N; // Normal
    float   d; // Distance to origin
};

struct Frustum
{
    vec4    N[4]; // Planes frustum
    float   d[4]; // Planes distances
};

struct Sphere
{
    vec3    c; // Center point
    float   r; // Radius 
};

layout (binding = 0, rgba32f) uniform readonly  image2D  gDepth;
layout (binding = 1, rg32ui)  uniform writeonly uimage2D gLightGrid;
layout (binding = 2, rgba32f) uniform writeonly image2D  gOutput;
layout (std430, binding = 3) writeonly buffer LightIndexCounter
{
    uint gLightIndexCounter[];
};
layout (std430, binding = 4) writeonly buffer LightIndexList
{
    uint gLightIndexList[];
};
layout (std430, binding = 5) readonly buffer LightsBuffer
{
    PointLight gPointLights[];
};
layout (std430, binding = 6) readonly buffer FrustumBuffer
{
    Frustum gFrustumBuffer[];
};

uniform mat4 invProjection;
uniform mat4 view;

uniform int numLights;
uniform int blockSize;
uniform int screenWidth;
uniform int screenHeight;

shared uint suMinDepth;
shared uint suMaxDepth;

shared uint sLightCount;
shared uint sLightIndexStartOffset;
shared uint sLightList[MAX_LIGHTS_PER_TILE];

shared Frustum sGroupFrustum;

// Convert clip space coordinates to view space
vec4 clipToView(vec4 clip)
{
    vec4 view = invProjection * clip;
    view = view / view.w;
    return view;
}

bool sphereInsidePlane(Sphere sphere, Plane plane)
{
    return dot(plane.N, sphere.c) - plane.d < -sphere.r;
}

bool sphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)
{
    bool result = true;

    /*
    // Check if in range of depth (forward and backward frustum plane)
    if (sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar)
    {
        result = false;
    }
    */
    
    // Check if in frustum with its 4 planes
    for (int i = 0; i < 4 && result; ++i)
    {
        Plane plane;
        plane.N = frustum.N[i].xyz;
        plane.d = frustum.d[i];
        if (sphereInsidePlane(sphere, plane))
        {
            result = false;
        }
    }
    
    return result;
}

// Atomic add a light index to the light list of a work group
void appendLight(uint lightIndex)
{
    uint index; // Index into the visible lights array
    index = atomicAdd(sLightCount, 1);
    if (sLightCount < MAX_LIGHTS_PER_TILE) // should be MAX_LIGHTS_PER_TILE
    {
        sLightList[index] = lightIndex;
    }
}

void main()
{
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    float fDepth = imageLoad(gDepth, texCoord).r;
    uint uDepth = floatBitsToUint(fDepth);

    // Setting group shared variables
    if (gl_LocalInvocationIndex == 0)
    {
        suMinDepth = 0xffffffff;
        suMaxDepth = 0;
        sLightCount = 0;
        sGroupFrustum = gFrustumBuffer[gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_NumWorkGroups.x)];
    }
    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0 && gl_GlobalInvocationID.z == 0)
    {
        gLightIndexCounter[0] = 0;
    }

    barrier();

    atomicMin(suMinDepth, uDepth);
    atomicMax(suMaxDepth, uDepth);

    barrier();

    float fMinDepth = uintBitsToFloat(suMinDepth);
    float fMaxDepth = uintBitsToFloat(suMaxDepth);

    float minDepthVS = clipToView(vec4(0, 0, fMinDepth, 1)).z;
    float maxDepthVS = clipToView(vec4(0, 0, fMaxDepth, 1)).z;
    float nearClipVS = clipToView(vec4(0, 0, 0, 1)).z;

    //imageStore(gOutput, texCoord, vec4(vec3(minDepthVS), 0.75));

    for (uint i = gl_LocalInvocationIndex; i < numLights; i += blockSize * blockSize)
    {
        PointLight pointLight = gPointLights[i];
        Sphere sphere;
        sphere.c = pointLight.positionVS.xyz;
        sphere.r = pointLight.radius;

        if (sphereInsideFrustum(sphere, sGroupFrustum, minDepthVS, maxDepthVS))
        {
            appendLight(i);          
        }
    }

    barrier();

    //imageStore(gOutput, texCoord, vec4(vec3(float(sLightCount)/min(MAX_LIGHTS_PER_TILE,numLights)), 0.85));

    if (gl_LocalInvocationIndex == 0)
    {
        sLightIndexStartOffset = atomicAdd(gLightIndexCounter[0], sLightCount);
        imageStore(gLightGrid, texCoord, uvec4(uvec2(sLightIndexStartOffset, sLightCount), 0, 0));
    }

    barrier();

    for (uint i = gl_LocalInvocationIndex; i < sLightCount; i += blockSize * blockSize)
    {
        gLightIndexList[sLightIndexStartOffset + i] = sLightList[i];
    }
}
